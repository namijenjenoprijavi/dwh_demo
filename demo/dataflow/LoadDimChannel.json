{
	"name": "LoadDimChannel",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "ChannelTypeTbl",
						"type": "DatasetReference"
					},
					"name": "DimCustomerSrc"
				},
				{
					"dataset": {
						"referenceName": "ChannelTypeTbl",
						"type": "DatasetReference"
					},
					"name": "ExistingRecords"
				},
				{
					"dataset": {
						"referenceName": "DimChannelTbl",
						"type": "DatasetReference"
					},
					"name": "MaxChannelDWId"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "DimChannelTbl",
						"type": "DatasetReference"
					},
					"name": "InsertSink"
				},
				{
					"dataset": {
						"referenceName": "DimChannelTbl",
						"type": "DatasetReference"
					},
					"name": "UpdateSink"
				}
			],
			"transformations": [
				{
					"name": "ExistingRecordsz"
				},
				{
					"name": "SourceHash"
				},
				{
					"name": "Exists"
				},
				{
					"name": "Lookup"
				},
				{
					"name": "ConditionalSplit"
				},
				{
					"name": "JoinMax"
				},
				{
					"name": "SurrogateKey"
				},
				{
					"name": "InsertDerivedColumn"
				},
				{
					"name": "AlterRow"
				},
				{
					"name": "UpdateDerived"
				},
				{
					"name": "UpdateAlterRow"
				}
			],
			"script": "source(output(\n\t\tChannelId as integer,\n\t\tChannelType as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> DimCustomerSrc\nsource(output(\n\t\tChannelDWId as integer,\n\t\tChannelType as string,\n\t\tDWRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: '\\nselect ChannelDWId, ChannelType, DWRecordHash from  Model.DimChannel',\n\tformat: 'query') ~> ExistingRecords\nsource(output(\n\t\tMaxChannelDWId as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxChannelDWId = isnull(max(ChannelDWId),0) \\nFROM Model.DimChannel',\n\tformat: 'query') ~> MaxChannelDWId\nExistingRecords select(mapColumn(\n\t\tExistingChannelDWId = ChannelDWId,\n\t\tExistingChannelType = ChannelType,\n\t\tExistingDWRecordHash = DWRecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> ExistingRecordsz\nDimCustomerSrc derive(SourceRecordHash = sha2(256, ChannelId, ChannelType)) ~> SourceHash\nSourceHash, ExistingRecordsz exists(SourceRecordHash == ExistingDWRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, ExistingRecordsz lookup(ChannelId == ExistingChannelDWId,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nLookup split(isNull(ExistingChannelType),\n\tdisjoint: false) ~> ConditionalSplit@(NewItems, UpdatedItem)\nConditionalSplit@NewItems, MaxChannelDWId join(1==1,\n\tjoinType:'cross',\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewChannelDWId as long),\n\tstartAt: 1L) ~> SurrogateKey\nSurrogateKey derive(NewChannelDWId = NewChannelDWId + MaxChannelDWId,\n\t\tDWIsCurrent = toBoolean('1'),\n\t\tDwEfectivStartDate = currentUTC(),\n\t\tDwEfectivEndDate = toDate('2999-12-31'),\n\t\tRecordCreatedDate = currentUTC(),\n\t\tRecordLastUpdatedDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRow\nConditionalSplit@UpdatedItem derive(RecordLastUpdatedDate = currentUTC()) ~> UpdateDerived\nUpdateDerived alterRow(updateIf(1==1)) ~> UpdateAlterRow\nAlterRow sink(input(\n\t\tChannelDWId as integer,\n\t\tChannelId as integer,\n\t\tChannelType as string,\n\t\tDWRecordHash as string,\n\t\tDwEfectivStartDate as date,\n\t\tDwEfectivEndDate as date,\n\t\tDwIsCurrentFlag as boolean,\n\t\tRecordCreatedDate as date,\n\t\tRecordLastUpdatedDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tmapColumn(\n\t\tChannelDWId = NewChannelDWId,\n\t\tChannelId,\n\t\tChannelType,\n\t\tDWRecordHash = SourceRecordHash,\n\t\tDwEfectivStartDate,\n\t\tDwEfectivEndDate,\n\t\tDwIsCurrentFlag = DWIsCurrent,\n\t\tRecordCreatedDate,\n\t\tRecordLastUpdatedDate\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> InsertSink\nUpdateAlterRow sink(input(\n\t\tChannelDWId as integer,\n\t\tChannelId as integer,\n\t\tChannelType as string,\n\t\tDWRecordHash as string,\n\t\tDwEfectivStartDate as date,\n\t\tDwEfectivEndDate as date,\n\t\tDwIsCurrentFlag as boolean,\n\t\tRecordCreatedDate as date,\n\t\tRecordLastUpdatedDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['ChannelDWId'],\n\tformat: 'table',\n\tmapColumn(\n\t\tChannelDWId = ExistingChannelDWId,\n\t\tChannelType,\n\t\tDWRecordHash = SourceRecordHash,\n\t\tRecordLastUpdatedDate\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> UpdateSink"
		}
	}
}