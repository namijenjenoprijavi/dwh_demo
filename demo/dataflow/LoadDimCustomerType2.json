{
	"name": "LoadDimCustomerType2",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "CustomerTbl",
						"type": "DatasetReference"
					},
					"name": "DimCustomerSrc"
				},
				{
					"dataset": {
						"referenceName": "CustomerTbl",
						"type": "DatasetReference"
					},
					"name": "ExistingRecords"
				},
				{
					"dataset": {
						"referenceName": "CustomerTbl",
						"type": "DatasetReference"
					},
					"name": "MaxCustomerDWId"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "DimCustomerTbl",
						"type": "DatasetReference"
					},
					"name": "InsertSink"
				},
				{
					"dataset": {
						"referenceName": "DimCustomerTbl",
						"type": "DatasetReference"
					},
					"name": "sink1"
				},
				{
					"dataset": {
						"referenceName": "DimCustomerTbl",
						"type": "DatasetReference"
					},
					"name": "sink2"
				}
			],
			"transformations": [
				{
					"name": "ExistingRecordsz"
				},
				{
					"name": "SourceHash"
				},
				{
					"name": "Exists"
				},
				{
					"name": "Lookup"
				},
				{
					"name": "ConditionalSplit"
				},
				{
					"name": "JoinMax"
				},
				{
					"name": "SurrogateKey"
				},
				{
					"name": "InsertDerivedColumn"
				},
				{
					"name": "AlterRow"
				},
				{
					"name": "DerivedColumn1"
				},
				{
					"name": "AlterRow1"
				},
				{
					"name": "ConditionalSplit1"
				},
				{
					"name": "ConditionalSplit2"
				},
				{
					"name": "DerivedColumn2"
				},
				{
					"name": "AlterRow2"
				},
				{
					"name": "Select1"
				}
			],
			"script": "source(output(\n\t\tCustomerId as integer,\n\t\tCompanyName as string,\n\t\tIndustry as string,\n\t\tSegment as string,\n\t\tAdress as string,\n\t\tCity as string,\n\t\tLong as decimal(18,2),\n\t\tLat as decimal(18,2)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> DimCustomerSrc\nsource(output(\n\t\tCustomerDWId as integer,\n\t\tCustomerId as integer,\n\t\tDWRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'select CustomerDWId, CustomerId, DWRecordHash from  Model.DimCustomer\\nwhere DwIsCurrentFlag=1',\n\tformat: 'query') ~> ExistingRecords\nsource(output(\n\t\tMaxCustomerDWId as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxCustomerDWId = isnull(max(CustomerDWId),0) \\nFROM Model.DimCustomer',\n\tformat: 'query') ~> MaxCustomerDWId\nExistingRecords select(mapColumn(\n\t\tExistingCustomerDWId = CustomerDWId,\n\t\tExistingCustomerId = CustomerId,\n\t\tExistingDWRecordHash = DWRecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> ExistingRecordsz\nDimCustomerSrc derive(SourceRecordHash = sha2(256, CustomerId, CompanyName, Industry, Segment, Adress, City, Long, Lat )) ~> SourceHash\nSourceHash, ExistingRecordsz exists(SourceRecordHash == ExistingDWRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, ExistingRecordsz lookup(CustomerId == ExistingCustomerId,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nLookup split(isNull(ExistingCustomerId),\n\tdisjoint: false) ~> ConditionalSplit@(NewItems, UpdatedItem)\nConditionalSplit@NewItems, MaxCustomerDWId join(1==1,\n\tjoinType:'cross',\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewCutomerDWId as long),\n\tstartAt: 1L) ~> SurrogateKey\nSurrogateKey derive(NewCustomerDWId = NewCutomerDWId + MaxCustomerDWId,\n\t\tDWIsCurrent = toBoolean('1'),\n\t\tDwEfectivStartDate = toDate('2018-01-01'),\n\t\tDwEfectivEndDate = toDate('2999-12-31'),\n\t\tRecordCreatedDate = currentUTC(),\n\t\tRecordLastUpdatedDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRow\nConditionalSplit1@ForInsert derive(DWIsCurrent = toBoolean('1'),\n\t\tDwEfectivEndDate = toDate('2999-12-31'),\n\t\tDwEfectivStartDate = currentUTC(),\n\t\tRecordLastUpdatedDate = currentUTC(),\n\t\tRecordCreatedDate = currentUTC()) ~> DerivedColumn1\nDerivedColumn1 alterRow(insertIf(1==1)) ~> AlterRow1\nConditionalSplit@UpdatedItem split(SourceRecordHash!=ExistingDWRecordHash,\n\tdisjoint: false) ~> ConditionalSplit1@(ForInsert)\nConditionalSplit@UpdatedItem split(SourceRecordHash!=ExistingDWRecordHash,\n\tdisjoint: false) ~> ConditionalSplit2@(ForUpdate)\nConditionalSplit2@ForUpdate derive(DWIsCurrent = toBoolean('0'),\n\t\tDwEfectivEndDate = addDays(toDate(currentUTC()), -1),\n\t\tRecordLastUpdatedDate = currentUTC()) ~> DerivedColumn2\nDerivedColumn2 alterRow(updateIf(1==1)) ~> AlterRow2\nAlterRow2 select(mapColumn(\n\t\tCustomerId,\n\t\tCompanyName,\n\t\tIndustry,\n\t\tSegment,\n\t\tAdress,\n\t\tCity,\n\t\tLong,\n\t\tLat,\n\t\tSourceRecordHash,\n\t\tExistingCustomerDWId,\n\t\tExistingCustomerId,\n\t\tDWRecordHash = ExistingDWRecordHash,\n\t\tDWIsCurrent,\n\t\tDwEfectivEndDate,\n\t\tRecordLastUpdatedDate\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Select1\nAlterRow sink(input(\n\t\tCustomerDWId as integer,\n\t\tCustomerId as integer,\n\t\tCompanyName as string,\n\t\tIndustry as string,\n\t\tSegment as string,\n\t\tAdress as string,\n\t\tCity as string,\n\t\tLong as decimal(18,2),\n\t\tLat as decimal(18,2),\n\t\tDWRecordHash as string,\n\t\tDwEfectivStartDate as date,\n\t\tDwEfectivEndDate as date,\n\t\tDwIsCurrentFlag as boolean,\n\t\tRecordCreatedDate as date,\n\t\tRecordLastUpdatedDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tmapColumn(\n\t\tCustomerDWId = NewCutomerDWId,\n\t\tCustomerId,\n\t\tCompanyName,\n\t\tIndustry,\n\t\tSegment,\n\t\tAdress,\n\t\tCity,\n\t\tLong,\n\t\tLat,\n\t\tDWRecordHash = SourceRecordHash,\n\t\tDwEfectivStartDate,\n\t\tDwEfectivEndDate,\n\t\tDwIsCurrentFlag = DWIsCurrent,\n\t\tRecordCreatedDate,\n\t\tRecordLastUpdatedDate\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> InsertSink\nAlterRow1 sink(input(\n\t\tCustomerDWId as integer,\n\t\tCustomerId as integer,\n\t\tCompanyName as string,\n\t\tIndustry as string,\n\t\tSegment as string,\n\t\tAdress as string,\n\t\tCity as string,\n\t\tLong as decimal(18,2),\n\t\tLat as decimal(18,2),\n\t\tDWRecordHash as string,\n\t\tDwEfectivStartDate as date,\n\t\tDwEfectivEndDate as date,\n\t\tDwIsCurrentFlag as boolean,\n\t\tRecordCreatedDate as date,\n\t\tRecordLastUpdatedDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tmapColumn(\n\t\tCustomerDWId = ExistingCustomerDWId,\n\t\tCustomerId,\n\t\tCompanyName,\n\t\tIndustry,\n\t\tSegment,\n\t\tAdress,\n\t\tCity,\n\t\tLong,\n\t\tLat,\n\t\tDWRecordHash = SourceRecordHash,\n\t\tDwEfectivStartDate,\n\t\tDwEfectivEndDate,\n\t\tDwIsCurrentFlag = DWIsCurrent,\n\t\tRecordCreatedDate,\n\t\tRecordLastUpdatedDate\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink1\nSelect1 sink(input(\n\t\tCustomerDWId as integer,\n\t\tCustomerId as integer,\n\t\tCompanyName as string,\n\t\tIndustry as string,\n\t\tSegment as string,\n\t\tAdress as string,\n\t\tCity as string,\n\t\tLong as decimal(18,2),\n\t\tLat as decimal(18,2),\n\t\tDWRecordHash as string,\n\t\tDwEfectivStartDate as date,\n\t\tDwEfectivEndDate as date,\n\t\tDwIsCurrentFlag as boolean,\n\t\tRecordCreatedDate as date,\n\t\tRecordLastUpdatedDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['DWRecordHash'],\n\tformat: 'table',\n\tmapColumn(\n\t\tDwEfectivEndDate,\n\t\tDwIsCurrentFlag = DWIsCurrent,\n\t\tRecordLastUpdatedDate,\n\t\tDWRecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink2"
		}
	}
}